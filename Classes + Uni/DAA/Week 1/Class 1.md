---
tags:
  - DAA
---
### Problem 1:
\# Comparisons: n-1 is the best case scenario of **comparisons**
\# Swaps: 0 is the best case scenario of **swaps**

Worst cases are $\frac{(n-1)*n}{2}$ 
Since every comparison results in a swap, this  is also applicable for swaps

> When counting comparisons in a sorting algorithm, you only count comparisons between elements of the input

Do whatever you can do to justify your goal. 

For example if you want to prove linear. Then you do $T(n) \leq x\times n$

I've heard that insertion sort is really good for when arrays are almost sorted, bubble feels good too, can you help articulate why insertion sort is better for that use case?

### Problem 9
When something is false just give a counterexample

FACT:
> Remember that for log(n) it is bigger than $n^k$ for all k that are bigger than 1; however, if we have a fraction then it is bigger after a certain point. Like, for $\log_{2}n > \sqrt{ n }, \forall n >16$ only 

### Problem 11
we assume $n \geq 1$ sometimes
for O$\left( n^\left( \frac{1}{2} \right) \right)$ operations, if the number that binds k is big, we can say that there is some k and we dont have to find it; however, the professor will let us know if we have to find it for small inputs.
Look at the facts and make clarifications if there are assumptions basically. Most of these will happen if we reach situations where 

Problem 12:
Must pick a specific log when proving something. 
Note that when the base gets smaller the number itself gets bigger.

Simplify e in problem 14. 
